# -*- coding: utf-8 -*-
"""Dogs vs. Cats prediction With CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JrMznoZFPemfp7_sfaASsOBE4Cx1zKAX

# Dogs vs. Cats prediction With CNN

Buatlah script python untuk menyelesaikan masalah klasifikasi yang ada di dataset berikut:

https://www.kaggle.com/competitions/dogs-vs-cats/overview

Metode yang digunakan adalah Convolutional Neural Network (CNN)
Tampilkan Akurasi, Presisi, Recall, dan F1-Score.

1. Extracting Dataset using Kaggle API
"""

# installing the Kaggle library
!pip install kaggle

"""2. Installed kaggle.json on the kagle API"""

# configuring the path of Kaggle.json file
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

"""3. Importing the Dog vs Cat Dataset from Kaggle"""

# Kaggle api
! kaggle competitions download -c dogs-vs-cats

!ls

!tar -xvf /content/dogs-vs-cats.zip -C /content

"""4. Extract dogs-vs-cats.zip"""

# extracting the compressed dataset
from zipfile import ZipFile

dataset = '/content/dogs-vs-cats.zip'

with ZipFile(dataset, 'r') as zip:
  zip.extractall()
  print('The dataset is extracted')

# extracting the compressed dataset
from zipfile import ZipFile

dataset = '/content/train.zip'

with ZipFile(dataset, 'r') as zip:
  zip.extractall()
  print('The dataset is extracted')

# extracting the compressed dataset
from zipfile import ZipFile

dataset = '/content/test1.zip'

with ZipFile(dataset, 'r') as zip:
  zip.extractall()
  print('The dataset is extracted')

"""5. View the number of train data"""

import os
# counting the number of files in train folder
path, dirs, files = next(os.walk('/content/train'))
file_count = len(files)
print('Number of images: ', file_count)

"""6. Printing the name of images"""

file_names = os.listdir('/content/train/')
print(file_names)

"""

```
`# Ini diformat sebagai kode`
```

7. Importing the Dependencies"""

import numpy as np
from PIL import Image
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from sklearn.model_selection import train_test_split
from google.colab.patches import cv2_imshow

"""8. Displaying the images of dogs and cats"""

# display dog image
img = mpimg.imread('/content/train/dog.8298.jpg')
imgplt = plt.imshow(img)
plt.show()

# display cat image
img = mpimg.imread('/content/train/cat.4352.jpg')
imgplt = plt.imshow(img)
plt.show()

"""9. see the number of images in the train data"""

file_names = os.listdir('/content/train/')

for i in range(5):

  name = file_names[i]
  print(name[0:3])

file_names = os.listdir('/content/train/')

dog_count = 0
cat_count = 0

for img_file in file_names:

  name = img_file[0:3]

  if name == 'dog':
    dog_count += 1

  else:
    cat_count += 1

print('Number of dog images =', dog_count)
print('Number of cat images =', cat_count)

"""10. Resizing all the images

The aim is to make it easier to classify images, such as changing the size so that they have the same size and have RGB colors
"""

#creating a directory for resized images
os.mkdir('/content/image resized')

original_folder = '/content/train/'
resized_folder = '/content/image resized/'

for i in range(2000):

  filename = os.listdir(original_folder)[i]
  img_path = original_folder+filename

  img = Image.open(img_path)
  img = img.resize((224, 224))
  img = img.convert('RGB')

  newImgPath = resized_folder+filename
  img.save(newImgPath)

# display resized dog image
img = mpimg.imread('/content/image resized/dog.10515.jpg')
imgplt = plt.imshow(img)
plt.show()

# display resized cat image
img = mpimg.imread('/content/image resized/cat.9521.jpg')
imgplt = plt.imshow(img)
plt.show()

"""11. **Creating labels for resized images of dogs and cats**

Cat --> 0

Dog --> 1
"""

# creaing a for loop to assign labels
filenames = os.listdir('/content/image resized/')


labels = []

for i in range(2000):

  file_name = filenames[i]
  label = file_name[0:3]

  if label == 'dog':
    labels.append(1)

  else:
    labels.append(0)

print(filenames[0:5])
print(len(filenames))

print(labels[0:5])
print(len(labels))

# counting the images of dogs and cats out of 2000 images
values, counts = np.unique(labels, return_counts=True)
print(values)
print(counts)

"""12. Converting all the resized images to numpy arrays"""

import cv2
import glob

image_directory = '/content/image resized/'
image_extension = ['png', 'jpg']

files = []

[files.extend(glob.glob(image_directory + '*.' + e)) for e in image_extension]

dog_cat_images = np.asarray([cv2.imread(file) for file in files])

"""13. displays image data in the form of an array"""

print(dog_cat_images)

type(dog_cat_images)

print(dog_cat_images.shape)

X = dog_cat_images
Y = np.asarray(labels)

"""14. **Train Test Split**

splitting data into two sets: one for training (train) and one for testing (test)
"""

X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=2)

print(X.shape, X_train.shape, X_test.shape)

"""1600 --> training images

400 --> test images

With image data that has been scaled to a range of 0 to 1, machine learning models will be easier to learn because the data has been normalized to the same scale.
"""

# scaling the data
X_train_scaled = X_train/255

X_test_scaled = X_test/255

print(X_train_scaled)

"""15. **Building the Neural Network**"""

import tensorflow as tf
import tensorflow_hub as hub

"""implementation of transfer learning using TensorFlow Hub to utilize pre-trained MobileNet V2 models in feature extraction tasks"""

mobilenet_model = 'https://tfhub.dev/google/tf2-preview/mobilenet_v2/feature_vector/4'

pretrained_model = hub.KerasLayer(mobilenet_model, input_shape=(224,224,3), trainable=False)

num_of_classes = 2

model = tf.keras.Sequential([

    pretrained_model,
    tf.keras.layers.Dense(num_of_classes)

])

model.summary()

"""This program builds an artificial neural network model that combines a pretrained model with a Dense layer for a two-class classification task

summary (summary) of the model to the screen. It will display information about how many parameters are in the model, the number of layers, the output size of each layer, and so on.
"""

model.compile(
    optimizer = 'adam',
    loss = tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
    metrics = ['acc']
)

"""the model has been setup for use with the Adam optimizer, using a sparse cross-entropy loss function, and measuring accuracy during training"""

model.fit(X_train_scaled, Y_train, epochs=5)

"""16. displays the level of accuracy during training"""

score, acc = model.evaluate(X_test_scaled, Y_test)
print('Test Loss =', score)
print('Test Accuracy =', acc)

"""17. **Predictive System**

program to carry out training whether it works well or not, by looking at the test data and labels, if it is a cat it will be labeled with 1 and if it is a dog it will be labeled 0
"""

input_image_path = input('Path of the image to be predicted: ')

input_image = cv2.imread(input_image_path)

cv2_imshow(input_image)

input_image_resize = cv2.resize(input_image, (224,224))

input_image_scaled = input_image_resize/255

image_reshaped = np.reshape(input_image_scaled, [1,224,224,3])

input_prediction = model.predict(image_reshaped)

print(input_prediction)

input_pred_label = np.argmax(input_prediction)

print(input_pred_label)

if input_pred_label == 0:
  print('The image represents a Cat')

else:
  print('The image represents a Dog')

input_image_path = input('Path of the image to be predicted: ')

input_image = cv2.imread(input_image_path)

cv2_imshow(input_image)

input_image_resize = cv2.resize(input_image, (224,224))

input_image_scaled = input_image_resize/255

image_reshaped = np.reshape(input_image_scaled, [1,224,224,3])

input_prediction = model.predict(image_reshaped)

print(input_prediction)

input_pred_label = np.argmax(input_prediction)

print(input_pred_label)

if input_pred_label == 0:
  print('The image represents a Cat')

else:
  print('The image represents a Dog')

import cv2
import numpy as np
from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score
from google.colab.patches import cv2_imshow  # Import cv2_imshow

# Define the true label for the image (0 for Cat, 1 for Dog)
true_label = 1  # Change this according to your actual label

input_image_path = input('Path of the image to be predicted: ')

input_image = cv2.imread(input_image_path)
cv2_imshow(input_image)  # Display the input image

input_image_resize = cv2.resize(input_image, (224, 224))
input_image_scaled = input_image_resize / 255
image_reshaped = np.reshape(input_image_scaled, [1, 224, 224, 3])

input_prediction = model.predict(image_reshaped)

input_pred_label = np.argmax(input_prediction)

if input_pred_label == 0:
    predicted_class = 'Cat'
else:
    predicted_class = 'Dog'

print(f'The image represents a {predicted_class}')

# Calculate accuracy, precision, recall, and F1-Score
true_labels = [true_label]
predicted_labels = [input_pred_label]

accuracy = accuracy_score(true_labels, predicted_labels)
precision = precision_score(true_labels, predicted_labels, average='binary')
recall = recall_score(true_labels, predicted_labels, average='binary')
f1 = f1_score(true_labels, predicted_labels, average='binary')

print(f'Accuracy: {accuracy}')
print(f'Precision: {precision}')
print(f'Recall: {recall}')
print(f'F1-Score: {f1}')